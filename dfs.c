#include <stdio.h>
#include <stdbool.h>

#define N 16
#define MAXPATH 256
/* 
     x:0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
  y:
  0   "0  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0",
  1   "0  0  1  1  0  1  1  1  1  1  1  1  1  0  0  0",
  2   "0  0  1  0  0  1  0  0  0  0  0  1  1  0  0  0",
  3   "0  0  1  0  0  1  0  1  1  1  0  1  1  0  0  0",
  4   "0  0  1  0  0  1  0  1  0  0  0  1  1  0  0  0",
  5   "0  0  1  1  1  1  0  1  0  1  1  1  1  0  0  0",
  6   "0  0  0  0  0  1  0  1  0  0  0  1  0  0  0  0",
  7   "0  0  0  0  0  1  0  C  C  1  0  1  0  0  0  0",
  8   "0  0  0  0  0  1  0  C  C  0  0  1  0  0  0  0",
  9   "0  1  1  1  1  1  0  1  1  1  0  1  1  1  1  0",
  10  "0  1  0  0  0  0  0  1  0  0  0  1  0  0  1  0",
  11  "0  1  1  1  1  1  1  1  0  1  1  1  1  0  1  0",
  12  "0  0  0  0  0  0  0  1  0  1  0  0  0  0  1  0",
  13  "0  1  1  1  1  1  1  1  0  1  1  1  1  1  1  0",
  14  "0  0  1  0  0  0  0  0  0  0  0  0  0  1  1  1",
  15  "S  1  1  1  1  1  1  1  1  1  1  1  1  1  1  0"

*/
// // Maze 0

// char maze[N][N+1] = {
//     "0110000000000000", 
//     "0011011111111000", 
//     "0010010000011000", 
//     "0010010111011000", 
//     "0010010100011000", 
//     "0011110101111000", 
//     "0000010100010000", 
//     "0000010CC1010000", // Tương ứng hàng 8 (Đích)
//     "0000010CC0010000", // Tương ứng hàng 7 (Đích)
//     "0111110111011110", 
//     "0100000100010010", 
//     "0111111101111010", 
//     "0000000101000010", 
//     "0111111101111110", 
//     "0010000000000111", 
//     "S111111111111110"  
//             //  
// };
// Maze 1: Đường đi Tương đối Ngắn và Rõ ràng
char maze[N][N+1] = {
    "1100000000000000",
    "1110111111111110",
    "0111100000010010",
    "0100111111110110",
    "0100010000010100",
    "0111010111110100",
    "0010010100011100",
    "0011110CC1110000", //
    "0000010CC1011110", //
    "0111110101000010",
    "0100011101111110",
    "0101110000010010",
    "0101011111110110",
    "0111010000110100",
    "1110011111100000",
    "S011110000000000"
            // 
};
// // Maze 2: Nhiều Ngõ Cụt và Đường Dài
// char maze[N][N+1] = {
//     "1111111110000000",
//     "0000010010111111",
//     "1111110010100001",
//     "1000010011101101",
//     "1011111110101001",
//     "1010001010111011",
//     "1011101010100010",
//     "1000101CC1111110",  //
//     "1111101CC0001010",  //
//     "0000101111111010",
//     "1111101010101010",
//     "1000101010101110",
//     "1011111010100010",
//     "1010000010111110",
//     "1011111110000010",
//     "S000000000111100"
//             //
// };
// // Maze 3: "Đảo" Phô mai ở Giữa và Nhiều Lối vào
// char maze[N][N+1] = {
//     "1111100000011111",
//     "0000100111010001",
//     "1111100101010111",
//     "1000111101010100",
//     "1011100001011100",
//     "1010111001001000",
//     "0010001001011110",
//     "1110001CC1000010",  //
//     "1011111CC1111110",  //
//     "1010001111000010",
//     "1010000001111110",
//     "1011101111000010",
//     "0010101000011110",
//     "1110101111110000",
//     "1000100000111111",
//     "S111111111100000"
//             //
// };


bool visited[N][N];
int pathX[MAXPATH], pathY[MAXPATH];
int pathLen = 0;

bool dfs(int x, int y) {
    // Kiểm tra nếu vị trí (x,y) nằm ngoài mê cung
    if (x < 0 || x >= N || y < 0 || y >= N) return false;
    // Kiểm tra nếu đây là tường ('0') hoặc đã được thăm
    if (maze[x][y] == '0' || visited[x][y]) return false;

    // Ghi lại đường đi
    pathX[pathLen] = x;
    pathY[pathLen] = y;
    pathLen++;

    // Nếu tìm thấy 'C' (Cheese), in đường đi và kết thúc
    if (maze[x][y] == 'C') {
        printf("Chuột đã tìm thấy phô mai!\nĐường đi:\n");
        for (int i = 0; i < pathLen; i++) {
            printf("(%d,%d) ", pathX[i], pathY[i]);
        }
        printf("\n");
        return true;
    }

    // Đánh dấu ô hiện tại đã được thăm
    visited[x][y] = true;

    // Thử di chuyển theo 4 hướng: Lên, Xuống, Trái, Phải
    if (dfs(x - 1, y)) return true; // Đi lên
    if (dfs(x + 1, y)) return true; // Đi xuống
    if (dfs(x, y - 1)) return true; // Đi sang trái
    if (dfs(x, y + 1)) return true; // Đi sang phải

    // Nếu không có hướng nào dẫn đến đích, quay lui (backtrack)
    pathLen--;
    return false;
}

int main() {
    int start_x, start_y;
    // Vòng lặp này sẽ tự động tìm tọa độ của 'S'
    // Trong ma trận mới, nó sẽ tìm thấy start_x = 15, start_y = 0
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (maze[i][j] == 'S') {
                start_x = i;
                start_y = j;
                // Có thể thêm break ở đây để tối ưu vì chỉ có một điểm S
                goto start_search;
            }
        }
    }

start_search:
    // Bắt đầu tìm kiếm từ vị trí 'S'
    if (!dfs(start_x, start_y)) {
        printf("Không tìm thấy đường đi đến phô mai.\n");
    }

    return 0;
}